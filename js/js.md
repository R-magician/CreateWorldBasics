### 相关视频 
 - https://www.bilibili.com/video/BV1RQ4y1D7UC?from=search&seid=2601592379219761853&spm_id_from=333.337.0.0
### 解析和执行过程
```
 javascript 是一种描述型的脚本语言，一种解析语言

 js执行过程分两大部分

    第一部分，解析过程，预编译期。对js代码中声明的所有变量函数进行预处理。这里仅仅是声明函数和变量，开辟一块内存空间。不进行赋值操作

    第二部分，执行过程，浏览器的js引擎对于每个代码块进行顺序执行

    总的来说js执行分为两个部分，解析过程：按照代码块一段一段进行解析；执行过程：按照代码块顺序逐行执行
    因为是解析语言，所以在解析过程中有错误不会提示，也可以理解js不会出现编译错误；但在运行时出现错误程序将会停止执行
```

### 全局预处理
```
 预处理：创建一个词法环境，扫描JS中声明的函数。用var定义的变量并将他们加到预处理的词法环境中去

 预处理阶段先读取代码块，不是一行一行的解析执行定义的方法和变量，会放到不同的词法环境中(我觉得应该是作用域中)

 预处理的函数必须是js中用声明的方式声明的函数(不是函数表达式 => var i=()=>{} )
    函数表达式在window的词法环境中会识别不了，要报错
```

### 命名冲突
 - 在变量和函数同名冲突
   - 函数优先，最终结果往往是指向函数的引用
   - 同名的函数或变量，只有后面的函数方法会有效
   - 输出的时候注意看函数是否带了括号

### 函数冲突原则
 - 函数声明有冲突时，会覆盖
 - 变量声明时有冲突，会忽略
 - 没有用声明的变量会变成外部成员，即全局变量

### 作用域
 - 作用域决定了代码块中变量和其他资源的可见性
 - 作用域是一个独立的地盘，让变量函数不会外泄暴露出去，隔离变量
 - 全局作用域
   - 未定义直接赋值的变量自动声明为拥有全局作用域
   - 所有window对象属性拥有全局作用域
   - 容易污染全局命名空间
 - 局部作用域
   - 一般只在固定的代码片段可以访问到函数和变量
   - 最大的作用域可以隔离变量
   - 内层作用域可以访问外层作用域的变量，反之则不行
 - let : 声明的变量和函数不会被提升到代码块顶部,禁止重命名
 - const : 和let差不多,静态变量,只能在声明时候赋值

### 作用域链
 - 自由变量
   - 当前作用域没有定义的变量，顺着作用域链向上寻找
 - 作用域链
   - 当前作用域一层一层向外层作用域向上寻找，直到全局作用域没找到，就宣布放弃。这种一层一层的关系就是作用域链
 - 自由变量取值
   - 取值的时候要在创建(声明)作用域 的函数中取值  (是创建不是调用)

### 变量提升和函数提升
 - 当前作用域和外层作用域存在同名的变量，在当前作用域未定义前调用此变量，那么打印出来的值，只会是undefined，不会是上层作用域同名变量的值，因为当前作用域在预编译的时候把变量提升到上面，执行的时候可以找到变量，但是未赋值
 - 若当前作用域和外层作用域存在同名的变量，要注意预编译时的提升变量机制
 - 函数提升---可以在声明函数之前调用
 - 函数提升是必要的，是js规定好的
 - 变量提升是js语言的问题，在开发提升尽量避免变量提升
 - 在同一个作用域中存在多个同名函数声明，后面的会覆盖前面的函数声明
 - 函数表达式是不会提升的(如：var i=()=>{})
 - 封装好的类库应该包裹在{}里面，这样才会有自己的作用域，不会和其他人的代码冲突
 - 变量提升是js中的一个bug，函数提升是js必须要进行的(设计时是有目的的)

### 变量的本质
 - 保存数据的一串符号
 - 保存在计算机中的数据，在程序运行时读取这段数据时应该如何找到这个内存地址(通过变量)
 - 全局变量
   - 当js加载到改变量所在行时产生
   - js代码加载完毕，变量死亡
 - 局部变量
   - 当js加载到改变量所在行时产生
   - 当函数执行完毕时死亡

### 变量的类型
 - (0.1+0.2=0.30000000...004)
   - 因为0.1和0.2是先转成二进制存储到计算机里面进行运算的，转换的过程中会产生无线循环，只有通过截取运算

### js中的判空方法
 - 判断变量为空
   - obj == null                能判断变量为null或者undefined
   - obj == undefined           只能判断变量为undefined
 - 判断对象为空
   - Object.getOwnPropertyNames(obj).length == 0
   - JSON.stringify(obj) == "{}"
   - Object.keys(obj).length == 0
   - 还有就是通过hasOwnProperty循环遍历
 - 判断是否为空数组
   - array.instanceof Array         判断array数据类型是否为数组
   - array.length == 0
 - 判断空串
   - str ===''
   - str.trim().length ==0

### 数组类型
 - array instanceof Array                       判断变量是数组
 - obj instanceof object                        判断变量是对象     